{
    "summary": "The code develops a component class for detecting rectangular shapes and identifying lines in images, incorporating methods for detection, relationship determination, position conversion, merging, clipping, and optional OpenCV display.",
    "details": [
        {
            "comment": "The code defines a class \"Component\" and several functions. The class initializes with region and image shape, and calculates its boundary and bounding box. The function \"cvt_compos_relative_pos\" adjusts the position of compositions relative to a base. \"compos_containment\" determines containment relationships between compositions. \"compos_update\" updates component properties based on image shape.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":0-35",
            "content": "from component_detection.lib_ip.Bbox import Bbox\nimport component_detection.lib_ip.ip_draw as draw\nimport cv2\ndef cvt_compos_relative_pos(compos, col_min_base, row_min_base):\n    for compo in compos:\n        compo.compo_relative_position(col_min_base, row_min_base)\ndef compos_containment(compos):\n    for i in range(len(compos) - 1):\n        for j in range(i + 1, len(compos)):\n            relation = compos[i].compo_relation(compos[j])\n            if relation == -1:\n                compos[j].contain.append(i)\n            if relation == 1:\n                compos[i].contain.append(j)\ndef compos_update(compos, org_shape):\n    for i, compo in enumerate(compos):\n        # start from 1, id 0 is background\n        compo.compo_update(i + 1, org_shape)\nclass Component:\n    def __init__(self, region, image_shape):\n        self.id = None\n        self.region = region\n        self.boundary = self.compo_get_boundary()\n        self.bbox = self.compo_get_bbox()\n        self.bbox_area = self.bbox.box_area\n        self.region_area = len(region)"
        },
        {
            "comment": "The code defines a class for a component, which has properties like width, height, area, and category. The `compo_update` method updates the component's attributes based on new information. The `put_bbox` method returns the bounding box of the component. The `compo_get_boundary` method retrieves the boundary coordinates for each row in the component.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":36-69",
            "content": "        self.width = len(self.boundary[0])\n        self.height = len(self.boundary[2])\n        self.image_shape = image_shape\n        self.area = self.width * self.height\n        self.category = 'Compo'\n        self.contain = []\n        self.rect_ = None\n        self.line_ = None\n        self.redundant = False\n    def compo_update(self, id, org_shape):\n        self.id = id\n        self.image_shape = org_shape\n        self.width = self.bbox.width\n        self.height = self.bbox.height\n        self.bbox_area = self.bbox.box_area\n        self.area = self.width * self.height\n    def put_bbox(self):\n        return self.bbox.put_bbox()\n    def compo_update_bbox_area(self):\n        self.bbox_area = self.bbox.bbox_cal_area()\n    def compo_get_boundary(self):\n        '''\n        get the bounding boundary of an object(region)\n        boundary: [top, bottom, left, right]\n        -> up, bottom: (column_index, min/max row border)\n        -> left, right: (row_index, min/max column border) detect range of each row\n        '''\n        border_up, border_bottom, border_left, border_right = {}, {}, {}, {}"
        },
        {
            "comment": "This code sets the top, bottom, left, and right column borders for each point in the region. The top (border_up) and bottom (border_bottom) borders are updated if a new point has a smaller row index than any existing top border or a larger row index than any existing bottom border. Similarly, the left (border_left) and right (border_right) borders are updated if a new point has a larger column index than any existing left border or a smaller column index than any existing right border. Finally, the boundaries are sorted in descending order for further processing.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":70-87",
            "content": "        for point in self.region:\n            # point: (row_index, column_index)\n            # up, bottom: (column_index, min/max row border) detect range of each column\n            if point[1] not in border_up or border_up[point[1]] > point[0]:\n                border_up[point[1]] = point[0]\n            if point[1] not in border_bottom or border_bottom[point[1]] < point[0]:\n                border_bottom[point[1]] = point[0]\n            # left, right: (row_index, min/max column border) detect range of each row\n            if point[0] not in border_left or border_left[point[0]] > point[1]:\n                border_left[point[0]] = point[1]\n            if point[0] not in border_right or border_right[point[0]] < point[1]:\n                border_right[point[0]] = point[1]\n        boundary = [border_up, border_bottom, border_left, border_right]\n        # descending sort\n        for i in range(len(boundary)):\n            boundary[i] = [[k, boundary[i][k]] for k in boundary[i].keys()]\n            boundary[i] = sorted(boundary[i], key=lambda x: x[0])"
        },
        {
            "comment": "The `Component.py` file contains a class for component detection. The function at lines 88-106, `compo_get_bbox`, calculates the top left and bottom right points of the boundary provided as input, returning a bounding box represented by its top left and bottom right corners. Another function `compo_is_rectangle` checks if the component is a rectangle based on given criteria such as minimum rectangular evenness and maximum dent ratio.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":88-106",
            "content": "        return boundary\n    def compo_get_bbox(self):\n        \"\"\"\n        Get the top left and bottom right points of boundary\n        :param boundaries: boundary: [top, bottom, left, right]\n                            -> up, bottom: (column_index, min/max row border)\n                            -> left, right: (row_index, min/max column border) detect range of each row\n        :return: corners: [(top_left, bottom_right)]\n                            -> top_left: (column_min, row_min)\n                            -> bottom_right: (column_max, row_max)\n        \"\"\"\n        col_min, row_min = (int(min(self.boundary[0][0][0], self.boundary[1][-1][0])), int(min(self.boundary[2][0][0], self.boundary[3][-1][0])))\n        col_max, row_max = (int(max(self.boundary[0][0][0], self.boundary[1][-1][0])), int(max(self.boundary[2][0][0], self.boundary[3][-1][0])))\n        bbox = Bbox(col_min, row_min, col_max, row_max)\n        return bbox\n    def compo_is_rectangle(self, min_rec_evenness, max_dent_ratio, test=False):\n        '''"
        },
        {
            "comment": "This code detects if an object is a rectangle by checking the evenness and dent of each border. It iterates through the borders, calculates the gradient and degree of surface changing to determine if it's a convex shape or has dents. It also calculates the maximum length of adjacent sides for comparison.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":107-129",
            "content": "        detect if an object is rectangle by evenness and dent of each border\n        '''\n        dent_direction = [1, -1, 1, -1]  # direction for convex\n        flat = 0\n        parameter = 0\n        for n, border in enumerate(self.boundary):\n            parameter += len(border)\n            # dent detection\n            pit = 0  # length of pit\n            depth = 0  # the degree of surface changing\n            if n <= 1:\n                adj_side = max(len(self.boundary[2]), len(self.boundary[3]))  # get maximum length of adjacent side\n            else:\n                adj_side = max(len(self.boundary[0]), len(self.boundary[1]))\n            # -> up, bottom: (column_index, min/max row border)\n            # -> left, right: (row_index, min/max column border) detect range of each row\n            abnm = 0\n            for i in range(int(3 + len(border) * 0.02), len(border) - 1):\n                # calculate gradient\n                difference = border[i][1] - border[i + 1][1]\n                # the degree of surface changing"
        },
        {
            "comment": "This code is part of a function that detects components in an image. It checks the depth and abnormality of each side of a potential rectangle to determine if it is actually rectangular or not. If the depth is too large (ignoring noise at the start), it counts as an abnormal change. If the total abnormal count exceeds 10% of the shape's length, it classifies the shape as non-rectangular and returns False. The code continues to the next iteration.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":130-148",
            "content": "                depth += difference\n                # ignore noise at the start of each direction\n                if i / len(border) < 0.08 and (dent_direction[n] * difference) / adj_side > 0.5:\n                    depth = 0  # reset\n                # print(border[i][1], i / len(border), depth, (dent_direction[n] * difference) / adj_side)\n                # if the change of the surface is too large, count it as part of abnormal change\n                if abs(depth) / adj_side > 0.3:\n                    abnm += 1  # count the size of the abnm\n                    # if the abnm is too big, the shape should not be a rectangle\n                    if abnm / len(border) > 0.1:\n                        if test:\n                            print('abnms', abnm, abnm / len(border))\n                            draw.draw_boundary([self], self.image_shape, show=True)\n                        self.rect_ = False\n                        return False\n                    continue\n                else:\n                    # reset the abnm if the depth back to normal"
        },
        {
            "comment": "The code checks if the surface is changing to a pit and classifies it as such. It also counts flat surfaces and ignores irregular shapes or text. If the number of pits exceeds a certain threshold, the shape is not considered rectangular.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":149-171",
            "content": "                    abnm = 0\n                # if sunken and the surface changing is large, then counted as pit\n                if dent_direction[n] * depth < 0 and abs(depth) / adj_side > 0.15:\n                    pit += 1\n                    continue\n                # if the surface is not changing to a pit and the gradient is zero, then count it as flat\n                if abs(depth) < 1 + adj_side * 0.015:\n                    flat += 1\n                if test:\n                    print(depth, adj_side, flat)\n            # if the pit is too big, the shape should not be a rectangle\n            if pit / len(border) > max_dent_ratio:\n                if test:\n                    print('pit', pit, pit / len(border))\n                    draw.draw_boundary([self], self.image_shape, show=True)\n                self.rect_ = False\n                return False\n        if test:\n            print(flat / parameter, '\\n')\n            draw.draw_boundary([self], self.image_shape, show=True)\n        # ignore text and irregular shape"
        },
        {
            "comment": "This code snippet checks if an object is a line by evaluating its boundary. It first calculates the slimness of the object horizontally and if it exceeds a certain threshold, it identifies the object as a line. The `min_line_thickness` parameter determines how thick a line should be to pass the check. If the slimness threshold is met, the `self.line_` attribute is set to True and the method returns True.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":172-196",
            "content": "        if self.height / self.image_shape[0] > 0.3:\n            min_rec_evenness = 0.85\n        if (flat / parameter) < min_rec_evenness:\n            self.rect_ = False\n            return False\n        self.rect_ = True\n        return True\n    def compo_is_line(self, min_line_thickness):\n        \"\"\"\n        Check this object is line by checking its boundary\n        :param boundary: boundary: [border_top, border_bottom, border_left, border_right]\n                                    -> top, bottom: list of (column_index, min/max row border)\n                                    -> left, right: list of (row_index, min/max column border) detect range of each row\n        :param min_line_thickness:\n        :return: Boolean\n        \"\"\"\n        # horizontally\n        slim = 0\n        for i in range(self.width):\n            if abs(self.boundary[1][i][1] - self.boundary[0][i][1]) <= min_line_thickness:\n                slim += 1\n        if slim / len(self.boundary[0]) > 0.93:\n            self.line_ = True\n            return True"
        },
        {
            "comment": "The code includes methods for detecting if a component is vertically continuous, determining the relationship between two components, converting to relative position based on a base coordinator, merging two components, and clipping an image.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":197-227",
            "content": "        # vertically\n        slim = 0\n        for i in range(self.height):\n            if abs(self.boundary[2][i][1] - self.boundary[3][i][1]) <= min_line_thickness:\n                slim += 1\n        if slim / len(self.boundary[2]) > 0.93:\n            self.line_ = True\n            return True\n        self.line_ = False\n        return False\n    def compo_relation(self, compo_b, bias=(0, 0)):\n        \"\"\"\n        :return: -1 : a in b\n                 0  : a, b are not intersected\n                 1  : b in a\n                 2  : a, b are identical or intersected\n        \"\"\"\n        return self.bbox.bbox_relation_nms(compo_b.bbox, bias)\n    def compo_relative_position(self, col_min_base, row_min_base):\n        '''\n        Convert to relative position based on base coordinator\n        '''\n        self.bbox.bbox_cvt_relative_position(col_min_base, row_min_base)\n    def compo_merge(self, compo_b):\n        self.bbox = self.bbox.bbox_merge(compo_b.bbox)\n        self.compo_update(self.id, self.image_shape)\n    def compo_clipping(self, img, pad=0, show=False):"
        },
        {
            "comment": "This code adjusts the bounding box coordinates, extracts a clipped image from the original, and optionally displays it using OpenCV.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Component.py\":228-237",
            "content": "        (column_min, row_min, column_max, row_max) = self.put_bbox()\n        column_min = max(column_min - pad, 0)\n        column_max = min(column_max + pad, img.shape[1])\n        row_min = max(row_min - pad, 0)\n        row_max = min(row_max + pad, img.shape[0])\n        clip = img[row_min:row_max, column_min:column_max]\n        if show:\n            cv2.imshow('clipping', clip)\n            cv2.waitKey()\n        return clip"
        }
    ]
}