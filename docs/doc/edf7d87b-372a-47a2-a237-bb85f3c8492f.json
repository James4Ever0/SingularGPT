{
    "summary": "The functions merge and remove components in binary images based on distance, height thresholds, and line orientation to generate a new list of compositions. The code detects and filters components using flood fill algorithm, categorizing them as blocks based on conditions such as size, area, shape, and type, and displays boundary information if `test` is set while saving the \"broad\" image if specified path is provided before returning the \"compos\" image.",
    "details": [
        {
            "comment": "This function merges intersecting or close components into one by checking if any compos have been merged and updating the dimensions of each compo. It takes a list of Component objects, original image, is_merge_contained_ele parameter, max_gap distance, and max_ele_height as parameters and returns a new list of Component objects.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":0-27",
            "content": "import cv2\nimport numpy as np\nimport component_detection.lib_ip.ip_draw as draw\nimport component_detection.lib_ip.ip_preprocessing as pre\nfrom component_detection.lib_ip.Component import Component\nimport component_detection.lib_ip.Component as Compo\nfrom config.CONFIG_ZEXUI import Config\nC = Config()\ndef merge_intersected_corner(compos, org, is_merge_contained_ele, max_gap=(0, 0), max_ele_height=25):\n    '''\n    Merge compos that intersect or are close to each other into one component.\n    :param compos: list of Component objects\n    :param org: original image\n    :param is_merge_contained_ele: if True, merge compos nested in others\n    :param max_gap: (horizontal_distance, vertical_distance) to be merge into one line/column\n    :param max_ele_height: if higher than it, recognize the compo as text\n    :return: list of Component objects\n    '''\n    # Check if any compos have been merged\n    changed = False\n    # Create a new list for merged compos\n    new_compos = []\n    # Update the dimensions of each compo\n    Compo.compos_update(compos, org.shape)"
        },
        {
            "comment": "The code iterates through compos and new_compos, checking their relations and merging or appending them based on certain conditions. If a compo is merged, the change is noted. The function returns the updated list of new_compos if any were merged, otherwise it returns the original list of compos.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":29-52",
            "content": "    # Loop through each compo\n    for i in range(len(compos)):\n        merged = False\n        cur_compo = compos[i]\n        # Loop through each merged compo\n        for j in range(len(new_compos)):\n            # Get the relation between compo[i] and compo[j]\n            relation = cur_compo.compo_relation(new_compos[j], max_gap)\n            # Merge compo[i] to compo[j] if:\n            # 1. compo[j] contains compo[i]\n            # 2. compo[j] intersects with compo[i] with certain intersection over union (iou)\n            # 3. is_merge_contained_ele is True and compo[j] is contained in compo[i]\n            if relation == 1 or relation == 2 or (is_merge_contained_ele and relation == -1):\n                new_compos[j].compo_merge(cur_compo)\n                cur_compo = new_compos[j]\n                merged = True\n                changed = True\n        # Append the unmerged compo to new_compos\n        if not merged:\n            new_compos.append(compos[i])\n    # If no compos have been merged, return the original list of compos"
        },
        {
            "comment": "This code contains a function that merges intersected components in a list of components. It repeatedly checks for intersections between each component and those already merged, marking them as \"merged\" if found. The process continues until no more merging can be performed.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":53-86",
            "content": "    if not changed:\n        return compos\n    # Otherwise, call the function recursively on the new_compos list until no more compos can be merged\n    else:\n        return merge_intersected_corner(new_compos, org, is_merge_contained_ele, max_gap, max_ele_height)\ndef merge_intersected_compos(compos):\n    '''\n    Merge intersected components in a list of components.\n    :param compos: a list of Component objects\n    :return: a new list of Component objects\n    '''\n    changed = True\n    while changed:\n        changed = False\n        temp_set = []\n        for compo_a in compos:\n            merged = False\n            for compo_b in temp_set:\n                if compo_a.compo_relation(compo_b) == 2:\n                    compo_b.compo_merge(compo_a)\n                    merged = True\n                    changed = True\n                    break\n            if not merged:\n                temp_set.append(compo_a)\n        compos = temp_set.copy()\n    return compos\ndef compo_relation(compo_a, compo_b):\n    '''\n    Check the relation between two components."
        },
        {
            "comment": "The function detects the relation between two components, whether one contains or intersects the other. It also checks if a component contains another or intersects with it. The code includes functions to determine if one component contains or intersects with another by checking their bounding boxes.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":88-119",
            "content": "    :param compo_a: a Component object\n    :param compo_b: a Component object\n    :return: an integer indicating the relation: 0 for no intersection, 1 for compo_b contains compo_a,\n             2 for compo_a intersects compo_b, and -1 for compo_a contains compo_b\n    '''\n    relation = 0\n    if compo_b.contains(compo_a):\n        relation = 1\n    elif compo_a.intersects(compo_b):\n        iou = compo_a.intersection_over_union(compo_b)\n        if iou >= 0.5:\n            relation = 2\n    elif compo_a.contains(compo_b):\n        relation = -1\n    return relation\ndef contains(compo_a, compo_b):\n    '''\n    Check if a component contains another component.\n    :param compo_a: a Component object\n    :param compo_b: a Component object\n    :return: a boolean indicating if compo_a contains compo_b\n    '''\n    return compo_a.bounding_box.contains(compo_b.bounding_box)\ndef intersects(compo_a, compo_b):\n    '''\n    Check if a component intersects another component.\n    :param compo_a: a Component object\n    :param compo_b: a Component object"
        },
        {
            "comment": "The code contains several functions for component detection and manipulation. The `intersection_over_union` function calculates the intersection over union between two components, while `compo_merge` merges two components into one by combining their bounding boxes and children. The `remove_contained_non_block_components` function removes non-block contained components from a list of components.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":120-153",
            "content": "    :return: a boolean indicating if compo_a intersects compo_b\n    '''\n    return compo_a.bounding_box.intersects(compo_b.bounding_box)\ndef intersection_over_union(compo_a, compo_b):\n    '''\n    Calculate the intersection over union (IOU) between two components.\n    :param compo_a: a Component object\n    :param compo_b: a Component object\n    :return: a float representing the IOU between compo_a and compo_b\n    '''\n    intersection = compo_a.bounding_box.intersection(compo_b.bounding_box)\n    union = compo_a.bounding_box.union(compo_b.bounding_box)\n    iou = intersection.area / union.area\n    return iou\ndef compo_merge(compo_a, compo_b):\n    '''\n    Merge two components.\n    :param compo_a: a Component object\n    :param compo_b: a Component object\n    :return: None\n    '''\n    new_bbox = compo_a.bounding_box.union(compo_b.bounding_box)\n    new_compo = Component(new_bbox)\n    new_compo.children = compo_a.children + compo_b.children\n    compo_a.children = []\n    compo_b.children = []\n    return new_compo\ndef remove_contained_non_block_components(compos):"
        },
        {
            "comment": "This code removes contained non-block components, gets unmarked components, and merges text-based components. It works by iterating over each component in a list, marking those that are contained or not of 'Block' category, then returning only the unmarked components. A separate function is provided to merge text components based on their height and category.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":154-189",
            "content": "    '''\n    Remove components that are contained by others and not of 'Block' category\n    '''\n    marked = np.full(len(compos), False)\n    mark_contained_non_block_components(compos, marked)\n    return get_unmarked_components(compos, marked)\ndef mark_contained_non_block_components(compos, marked):\n    '''\n    Mark contained non-block components\n    '''\n    for i in range(len(compos) - 1):\n        for j in range(i + 1, len(compos)):\n            relation = compos[i].compo_relation(compos[j])\n            if relation == -1 and compos[j].category != 'Block':\n                marked[i] = True\n            if relation == 1 and compos[i].category != 'Block':\n                marked[j] = True\ndef get_unmarked_components(compos, marked):\n    '''\n    Get unmarked components\n    '''\n    new_compos = []\n    for i in range(len(marked)):\n        if not marked[i]:\n            new_compos.append(compos[i])\n    return new_compos\ndef merge_text(compos, org_shape, max_word_gad=4, max_word_height=20):\n    def is_text(compo):\n        \"\"\"\n        Check if the component is text based on its height and category."
        },
        {
            "comment": "The code detects if a component is text based on its height and category. If it's not a text, it returns False. The is_same_line function checks if two components are on the same line by comparing their bounding boxes. It considers the minimum and maximum column and row values of each component to determine if they overlap, indicating they are on the same line.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":191-223",
            "content": "        Args:\n            compo: a component\n        Returns:\n            True if the component is text, False otherwise.\n        \"\"\"\n        height = compo.height\n        # ignore non-text\n        # if height / row > max_word_height_ratio\\\n        #         or compos[i].category != 'Text':\n        if height > max_word_height:\n            return False\n        else:\n            return True\n    def is_same_line(compo_a, compo_b):\n        \"\"\"\n        Check if two components are on the same line based on their bounding boxes.\n        Args:\n            compo_a: a component\n            compo_b: a component\n        Returns:\n            True if the two components are on the same line, False otherwise.\n        \"\"\"\n        (col_min_a, row_min_a, col_max_a, row_max_a) = compo_a.put_bbox()\n        (col_min_b, row_min_b, col_max_b, row_max_b) = compo_b.put_bbox()\n        col_min_s = max(col_min_a, col_min_b)\n        col_max_s = min(col_max_a, col_max_b)\n        row_min_s = max(row_min_a, row_min_b)\n        row_max_s = min(row_max_a, row_max_b)"
        },
        {
            "comment": "The code contains a function that checks if two components are close in position and returns True or False accordingly. It also includes a function to merge two components into a new one, which is used in another recursive function that merges text components until no more mergers can be made.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":225-257",
            "content": "        # on the same line\n        # if abs(row_min_a - row_min_b) < max_word_gad and abs(row_max_a - row_max_b) < max_word_gad:\n        if row_min_s < row_max_s:\n            # close distance\n            if col_min_s < col_max_s or \\\n                    (0 < col_min_b - col_max_a < max_word_gad) or (0 < col_min_a - col_max_b < max_word_gad):\n                return True\n        return False\n    def merge_components(compo_a, compo_b):\n        \"\"\"\n        Merge two components into a new one.\n        Args:\n            compo_a: a component\n            compo_b: a component\n        Returns:\n            A new component that is the merger of the two input components.\n        \"\"\"\n        new_compo = compo_a.compo_copy()\n        new_compo.compo_merge(compo_b)\n        return new_compo\n    def merge_text_recursive(compos):\n        \"\"\"\n        Recursive function that merges text components until no more mergers can be made.\n        Args:\n            compos: a list of components\n        Returns:\n            A new list of merged components."
        },
        {
            "comment": "This function takes a list of components and checks if any are text or on the same line. It merges similar components and returns a new list of components, recursively applying this process. If no changes were made, it simply returns the original list. The function also includes code to remove top or bottom corners from the component list based on the specified height threshold.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":258-290",
            "content": "        \"\"\"\n        changed = False\n        new_compos = []\n        for i in range(len(compos)):\n            merged = False\n            if not is_text(compos[i]):\n                new_compos.append(compos[i])\n                continue\n            for j in range(len(new_compos)):\n                if not is_text(new_compos[j]):\n                    continue\n                if is_same_line(compos[i], new_compos[j]):\n                    merged_compo = merge_components(compos[i], new_compos[j])\n                    new_compos[j] = merged_compo\n                    merged = True\n                    changed = True\n                    break\n            if not merged:\n                new_compos.append(compos[i])\n        if not changed:\n            return new_compos\n        else:\n            return merge_text_recursive(new_compos)\n    return merge_text_recursive(compos)\ndef rm_top_or_bottom_corners(components, org_shape, top_bottom_height=C.THRESHOLD_TOP_BOTTOM_BAR):\n    new_compos = []\n    height, width = org_shape[:2]\n    for compo in components:"
        },
        {
            "comment": "The function `rm_line_v_h` checks for continuous lines in the binary image. It returns the indices of any line that exceeds a certain length threshold (0.6 times the edge length). The function `put_bbox` of the `compo` object determines the bounding box of a component. Components that are too large are skipped, and the function `check_continuous_line` is used to check for continuous lines in vertical or horizontal directions.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":291-317",
            "content": "        (column_min, row_min, column_max, row_max) = compo.put_bbox()\n        # remove big ones\n        # if (row_max - row_min) / height > 0.65 and (column_max - column_min) / width > 0.8:\n        #     continue\n        if not (row_max < height * top_bottom_height[0] or row_min > height * top_bottom_height[1]):\n            new_compos.append(compo)\n    return new_compos\ndef rm_line_v_h(binary, show=False, max_line_thickness=C.THRESHOLD_LINE_THICKNESS):\n    def check_continuous_line(line, edge):\n        continuous_length = 0\n        line_start = -1\n        for j, p in enumerate(line):\n            if p > 0:\n                if line_start == -1:\n                    line_start = j\n                continuous_length += 1\n            elif continuous_length > 0:\n                if continuous_length / edge > 0.6:\n                    return [line_start, j]\n                continuous_length = 0\n                line_start = -1\n        if continuous_length / edge > 0.6:\n            return [line_start, len(line)]\n        else:"
        },
        {
            "comment": "This function iterates through each row of the binary image. If it detects a continuous line, it stores the line area in `line_area`. If it detects another line before the previous one ends (within `max_line_thickness` pixels), it calls `extract_line_area()` to extract and handle the line area. This process continues until all lines are processed or no more lines are detected.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":318-347",
            "content": "            return None\n    def extract_line_area(line, start_idx, flag='v'):\n        for e, l in enumerate(line):\n            if flag == 'v':\n                map_line[start_idx + e, l[0]:l[1]] = binary[start_idx + e, l[0]:l[1]]\n    map_line = np.zeros(binary.shape[:2], dtype=np.uint8)\n    cv2.imshow('binary', binary)\n    width = binary.shape[1]\n    start_row = -1\n    line_area = []\n    for i, row in enumerate(binary):\n        line_v = check_continuous_line(row, width)\n        if line_v is not None:\n            # new line\n            if start_row == -1:\n                start_row = i\n                line_area = []\n            line_area.append(line_v)\n        else:\n            # checking line\n            if start_row != -1:\n                if i - start_row < max_line_thickness:\n                    # binary[start_row: i] = 0\n                    # map_line[start_row: i] = binary[start_row: i]\n                    print(line_area, start_row, i)\n                    extract_line_area(line_area, start_row)\n                start_row = -1"
        },
        {
            "comment": "This code detects and removes horizontal lines from an image using binary thresholding. It iterates through each column, identifies continuous lines, and marks them in a separate map. If the line thickness is within the maximum limit, it replaces the binary image's corresponding columns with zeros. Finally, it displays the original image (binary) and the one with removed lines (map_line).",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":349-384",
            "content": "    height = binary.shape[0]\n    start_col = -1\n    for i in range(width):\n        col = binary[:, i]\n        line_h = check_continuous_line(col, height)\n        if line_h is not None:\n            # new line\n            if start_col == -1:\n                start_col = i\n        else:\n            # checking line\n            if start_col != -1:\n                if i - start_col < max_line_thickness:\n                    # binary[:, start_col: i] = 0\n                    map_line[:, start_col: i] = binary[:, start_col: i]\n                start_col = -1\n    binary -= map_line\n    if show:\n        cv2.imshow('no-line', binary)\n        cv2.imshow('lines', map_line)\n        cv2.waitKey()\ndef rm_line(binary,\n            max_line_thickness=C.THRESHOLD_LINE_THICKNESS,\n            min_line_length_ratio=C.THRESHOLD_LINE_MIN_LENGTH,\n            show=False, wait_key=0):\n    def is_valid_line(line):\n        line_length = 0\n        line_gap = 0\n        for j in line:\n            if j > 0:\n                if line_gap > 5:\n                    return False"
        },
        {
            "comment": "The code detects lines in a binary image and determines if they exceed 0.95 of the image's width to classify as valid lines. It also checks line thickness and gaps between lines. The maximum line thickness is considered, and the code switches between checking lines and gaps within a loop over each row of the binary image. The shape and type of the binary image are assigned to the board array, which is initialized with zeros using numpy's zeros function. Start and end rows for valid lines and potential gaps are tracked, along with boolean flags for line and gap checking states.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":385-416",
            "content": "                line_length += 1\n                line_gap = 0\n            elif line_length > 0:\n                line_gap += 1\n        if line_length / width > 0.95:\n            return True\n        return False\n    height, width = binary.shape[:2]\n    board = np.zeros(binary.shape[:2], dtype=np.uint8)\n    start_row, end_row = -1, -1\n    check_line = False\n    check_gap = False\n    for i, row in enumerate(binary):\n        # line_ratio = (sum(row) / 255) / width\n        # if line_ratio > 0.9:\n        if is_valid_line(row):\n            # new start: if it is checking a new line, mark this row as start\n            if not check_line:\n                start_row = i\n                check_line = True\n        else:\n            # end the line\n            if check_line:\n                # thin enough to be a line, then start checking gap\n                if i - start_row < max_line_thickness:\n                    end_row = i\n                    check_gap = True\n                else:\n                    start_row, end_row = -1, -1\n                check_line = False"
        },
        {
            "comment": "This code is responsible for image processing, specifically removing noise components and creating binary images. It includes functions to remove noise composites, identify and delete noisy regions in large images, and display the resulting binary image. The max_line_thickness and max_compo_scale parameters control the threshold values for line detection and composition removal respectively.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":417-452",
            "content": "        # check gap\n        if check_gap and i - end_row > max_line_thickness:\n            binary[start_row: end_row] = 0\n            start_row, end_row = -1, -1\n            check_line = False\n            check_gap = False\n    if (check_line and (height - start_row) < max_line_thickness) or check_gap:\n        binary[start_row: end_row] = 0\n    if show:\n        cv2.imshow('no-line binary', binary)\n        if wait_key is not None:\n            cv2.waitKey(wait_key)\n        if wait_key == 0:\n            cv2.destroyWindow('no-line binary')\ndef rm_noise_compos(compos):\n    compos_new = []\n    for compo in compos:\n        if compo.category == 'Noise':\n            continue\n        compos_new.append(compo)\n    return compos_new\ndef rm_noise_in_large_img(compos, org,\n                      max_compo_scale=C.THRESHOLD_COMPO_MAX_SCALE):\n    row, column = org.shape[:2]\n    remain = np.full(len(compos), True)\n    new_compos = []\n    for compo in compos:\n        if compo.category == 'Image':\n            for i in compo.contain:\n                remain[i] = False"
        },
        {
            "comment": "The function `detect_compos_in_img` takes in a list of compositions, a binary image, an organization (org) object, maximum composition scale, and optionally a boolean for showing images. It iterates through each composition and if the category is 'Image', it updates the bounding box area and clips the binary image to the composition's bounding box. It then detects components within the clipped image and appends non-recording component records to the `compos_new` list, if certain conditions are met (bbox area ratio, height, width). Finally, it returns the updated list of compositions.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":453-474",
            "content": "    for i in range(len(remain)):\n        if remain[i]:\n            new_compos.append(compos[i])\n    return new_compos\ndef detect_compos_in_img(compos, binary, org, max_compo_scale=C.THRESHOLD_COMPO_MAX_SCALE, show=False):\n    compos_new = []\n    row, column = binary.shape[:2]\n    for compo in compos:\n        if compo.category == 'Image':\n            compo.compo_update_bbox_area()\n            # org_clip = compo.compo_clipping(org)\n            # bin_clip = pre.binarization(org_clip, show=show)\n            bin_clip = compo.compo_clipping(binary)\n            bin_clip = pre.reverse_binary(bin_clip, show=show)\n            compos_rec, compos_nonrec = component_detection(bin_clip, test=False, step_h=10, step_v=10, rec_detect=True)\n            for compo_rec in compos_rec:\n                compo_rec.compo_relative_position(compo.bbox.col_min, compo.bbox.row_min)\n                if compo_rec.bbox_area / compo.bbox_area < 0.8 and compo_rec.bbox.height > 20 and compo_rec.bbox.width > 20:\n                    compos_new.append(compo_rec)"
        },
        {
            "comment": "This code is part of a component detection function in the \"ip_detection.py\" file. It filters out components from a list based on certain criteria such as minimum area, maximum height, aspect ratio, and size. The filtered components are added to a new list called \"compos_new\", which is then appended to the original list.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":475-499",
            "content": "                    # draw.draw_bounding_box(org, [compo_rec], show=True)\n            # compos_inner = component_detection(bin_clip, rec_detect=False)\n            # for compo_inner in compos_inner:\n            #     compo_inner.compo_relative_position(compo.bbox.col_min, compo.bbox.row_min)\n            #     draw.draw_bounding_box(org, [compo_inner], show=True)\n            #     if compo_inner.bbox_area / compo.bbox_area < 0.8:\n            #         compos_new.append(compo_inner)\n    compos += compos_new\ndef compo_filter(compos, min_area, img_shape):\n    max_height = img_shape[0] * 0.8\n    compos_new = []\n    for compo in compos:\n        if compo.area < min_area:\n            continue\n        if compo.height > max_height:\n            continue\n        ratio_h = compo.width / compo.height\n        ratio_w = compo.height / compo.width\n        if ratio_h > 50 or ratio_w > 40 or \\\n                (min(compo.height, compo.width) < 8 and max(ratio_h, ratio_w) > 10):\n            continue\n        compos_new.append(compo)"
        },
        {
            "comment": "The code checks if a compo is a block by examining the inner sides of its border. It scans four lines inside each border, top down for the top border, left to right for the left border, bottom up for the bottom border, and right to left for the right border. If any of these scans detect more than two blank lines, the compo is not considered a block.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":500-531",
            "content": "    return compos_new\ndef is_block(clip, thread=0.15):\n    '''\n    Block is a rectangle border enclosing a group of compos (consider it as a wireframe)\n    Check if a compo is block by checking if the inner side of its border is blank\n    '''\n    side = 4  # scan 4 lines inner forward each border\n    # top border - scan top down\n    blank_count = 0\n    for i in range(1, 5):\n        if sum(clip[side + i]) / 255 > thread * clip.shape[1]:\n            blank_count += 1\n    if blank_count > 2: return False\n    # left border - scan left to right\n    blank_count = 0\n    for i in range(1, 5):\n        if sum(clip[:, side + i]) / 255 > thread * clip.shape[0]:\n            blank_count += 1\n    if blank_count > 2: return False\n    side = -4\n    # bottom border - scan bottom up\n    blank_count = 0\n    for i in range(-1, -5, -1):\n        if sum(clip[side + i]) / 255 > thread * clip.shape[1]:\n            blank_count += 1\n    if blank_count > 2: return False\n    # right border - scan right to left\n    blank_count = 0\n    for i in range(-1, -5, -1):"
        },
        {
            "comment": "The code performs component detection on a binary image, calculating connected regions and bounding boundaries. It checks if the regions are rectangles to return all boundaries and rectangle boundaries. The function also categorizes components as blocks if they meet certain conditions.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":532-555",
            "content": "        if sum(clip[:, side + i]) / 255 > thread * clip.shape[0]:\n            blank_count += 1\n    if blank_count > 2: return False\n    return True\ndef compo_block_recognition(binary, compos, block_side_length=0.15):\n    height, width = binary.shape\n    for compo in compos:\n        if compo.height / height > block_side_length and compo.width / width > block_side_length:\n            clip = compo.compo_clipping(binary)\n            if is_block(clip):\n                compo.category = 'Block'\n# take the binary image as input\n# calculate the connected regions -> get the bounding boundaries of them -> check if those regions are rectangles\n# return all boundaries and boundaries of rectangles\ndef component_detection(binary, min_obj_area,\n                        line_thickness=C.THRESHOLD_LINE_THICKNESS,\n                        min_rec_evenness=C.THRESHOLD_REC_MIN_EVENNESS,\n                        max_dent_ratio=C.THRESHOLD_REC_MAX_DENT_RATIO,\n                        step_h = 5, step_v = 2,\n                        rec_detect=False, show=False, test=False):"
        },
        {
            "comment": "This function takes binary image, min/max object size and shape parameters, and returns the boundaries of detected components. It initializes a mask for each connected area and iterates through each row and column of the binary image to find non-zero pixels and add them to their respective lists.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":556-575",
            "content": "    \"\"\"\n    :param binary: Binary image from pre-processing\n    :param min_obj_area: If not pass then ignore the small object\n    :param min_obj_perimeter: If not pass then ignore the small object\n    :param line_thickness: If not pass then ignore the slim object\n    :param min_rec_evenness: If not pass then this object cannot be rectangular\n    :param max_dent_ratio: If not pass then this object cannot be rectangular\n    :return: boundary: [top, bottom, left, right]\n                        -> up, bottom: list of (column_index, min/max row border)\n                        -> left, right: list of (row_index, min/max column border) detect range of each row\n    \"\"\"\n    mask = np.zeros((binary.shape[0] + 2, binary.shape[1] + 2), dtype=np.uint8)\n    compos_all = []\n    compos_rec = []\n    compos_nonrec = []\n    row, column = binary.shape[0], binary.shape[1]\n    for i in range(0, row, step_h):\n        for j in range(i % 2, column, step_v):\n            if binary[i, j] == 255 and mask[i, j] == 0:\n                # get connected area"
        },
        {
            "comment": "This code snippet detects components in an image and filters out small regions. It uses flood filling to create a mask, then reshapes and filters the region to exclude small areas or potential lines. If `test` is set, it prints the area size and displays the boundary of each detected component.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":576-597",
            "content": "                # region = util.boundary_bfs_connected_area(binary, i, j, mask)\n                mask_copy = mask.copy()\n                ff = cv2.floodFill(binary, mask, (j, i), None, 0, 0, cv2.FLOODFILL_MASK_ONLY)\n                if ff[0] < min_obj_area: continue\n                mask_copy = mask - mask_copy\n                region = np.reshape(cv2.findNonZero(mask_copy[1:-1, 1:-1]), (-1, 2))\n                region = [(p[1], p[0]) for p in region]\n                # filter out some compos\n                component = Component(region, binary.shape)\n                # calculate the boundary of the connected area\n                # ignore small area\n                if component.width <= 3 or component.height <= 3:\n                    continue\n                # check if it is line by checking the length of edges\n                # if component.compo_is_line(line_thickness):\n                #     continue\n                if test:\n                    print('Area:%d' % (len(region)))\n                    draw.draw_boundary([component], binary.shape, show=True)"
        },
        {
            "comment": "This code detects and classifies components as either rectangular or non-rectangular based on evenness and dent ratio. It appends these components to separate lists. If \"rec_detect\" is True, it returns the rectangular and non-rectangular components separately; otherwise, it returns all detected components. The function also allows for visualization of component boundaries if \"show\" is set to True.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":599-626",
            "content": "                compos_all.append(component)\n                if rec_detect:\n                    # rectangle check\n                    if component.compo_is_rectangle(min_rec_evenness, max_dent_ratio):\n                        component.rect_ = True\n                        compos_rec.append(component)\n                    else:\n                        component.rect_ = False\n                        compos_nonrec.append(component)\n                if show:\n                    print('Area:%d' % (len(region)))\n                    draw.draw_boundary(compos_all, binary.shape, show=True)\n    # draw.draw_boundary(compos_all, binary.shape, show=True)\n    if rec_detect:\n        return compos_rec, compos_nonrec\n    else:\n        return compos_all\ndef nested_components_detection(grey, org, grad_thresh,\n                   show=False, write_path=None,\n                   step_h=10, step_v=10,\n                   line_thickness=C.THRESHOLD_LINE_THICKNESS,\n                   min_rec_evenness=C.THRESHOLD_REC_MIN_EVENNESS,\n                   max_dent_ratio=C.THRESHOLD_REC_MAX_DENT_RATIO):"
        },
        {
            "comment": "This code uses a flood fill algorithm to detect components in an image. It iterates through the image, ignoring already detected areas and using the flood fill function from cv2 (OpenCV) library. The result is a list of regions of interest, each represented as (top_left, bottom_right) coordinates.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":627-650",
            "content": "    '''\n    :param grey: grey-scale of original image\n    :return: corners: list of [(top_left, bottom_right)]\n                        -> top_left: (column_min, row_min)\n                        -> bottom_right: (column_max, row_max)\n    '''\n    compos = []\n    mask = np.zeros((grey.shape[0]+2, grey.shape[1]+2), dtype=np.uint8)\n    broad = np.zeros((grey.shape[0], grey.shape[1], 3), dtype=np.uint8)\n    broad_all = broad.copy()\n    row, column = grey.shape[0], grey.shape[1]\n    for x in range(0, row, step_h):\n        for y in range(0, column, step_v):\n            if mask[x, y] == 0:\n                # region = flood_fill_bfs(grey, x, y, mask)\n                # flood fill algorithm to get background (layout block)\n                mask_copy = mask.copy()\n                ff = cv2.floodFill(grey, mask, (y, x), None, grad_thresh, grad_thresh, cv2.FLOODFILL_MASK_ONLY)\n                # ignore small regions\n                if ff[0] < 500: continue\n                mask_copy = mask - mask_copy\n                region = np.reshape(cv2.findNonZero(mask_copy[1:-1, 1:-1]), (-1, 2))"
        },
        {
            "comment": "This code detects and filters components from an image based on size, area, shape, and type. It checks if the component is a line or a rectangle and skips those that do not meet the criteria. The threshold values for area and height are set to continue or skip processing.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":651-675",
            "content": "                region = [(p[1], p[0]) for p in region]\n                compo = Component(region, grey.shape)\n                # draw.draw_region(region, broad_all)\n                # if block.height < 40 and block.width < 40:\n                #     continue\n                if compo.height < 30:\n                    continue\n                # print(block.area / (row * column))\n                if compo.area / (row * column) > 0.9:\n                    continue\n                elif compo.area / (row * column) > 0.7:\n                    compo.redundant = True\n                # get the boundary of this region\n                # ignore lines\n                if compo.compo_is_line(line_thickness):\n                    continue\n                # ignore non-rectangle as blocks must be rectangular\n                if not compo.compo_is_rectangle(min_rec_evenness, max_dent_ratio):\n                    continue\n                # if block.height/row < min_block_height_ratio:\n                #     continue\n                compos.append(compo)"
        },
        {
            "comment": "This code segment saves the \"broad\" image to a specified path if \"write_path\" is not None, and then returns the \"compos\" image.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_detection.py\":676-681",
            "content": "                # draw.draw_region(region, broad)\n    if write_path is not None:\n        cv2.imwrite(write_path, broad)\n    return compos"
        }
    ]
}