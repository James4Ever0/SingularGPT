{
    "summary": "The `draw_line()` function is responsible for drawing lines and components' boundaries on an image, while the functions draw_region and draw_region_bin modify a board by coloring or marking specific points within a given region. If show is True, they display the modified board using cv2.imshow.",
    "details": [
        {
            "comment": "This function, located at \"SingularGPT/component_detection/lib_ip/ip_draw.py\":0-26, takes an original image (org), components' bounding boxes (bbox), color mapping for different components (color_map), line thickness (line), component class labels (compo_class), and a show or not parameter. It then creates a copy of the original image (board) and draws bounding boxes around each component in the original image, using the provided colors and line thickness. Additionally, it can optionally write the component class labels on top of the corresponding bounding box. Finally, if show is set to True, it will display the labeled image.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_draw.py\":0-26",
            "content": "import cv2\nimport numpy as np\nfrom random import randint as rint\nfrom config.CONFIG_ZEXUI import Config\nC = Config()\ndef draw_bounding_box_class(org, components, color_map=C.COLOR, line=2, show=False, write_path=None, name='board'):\n    \"\"\"\n    Draw bounding box of components with their classes on the original image\n    :param org: original image\n    :param components: bbox [(column_min, row_min, column_max, row_max)]\n                    -> top_left: (column_min, row_min)\n                    -> bottom_right: (column_max, row_max)\n    :param color_map: colors mapping to different components\n    :param line: line thickness\n    :param compo_class: classes matching the corners of components\n    :param show: show or not\n    :return: labeled image\n    \"\"\"\n    board = org.copy()\n    for compo in components:\n        bbox = compo.put_bbox()\n        board = cv2.rectangle(board, (bbox[0], bbox[1]), (bbox[2], bbox[3]), color_map[compo.category], line)\n        # board = cv2.putText(board, compo.category, (bbox[0]+5, bbox[1]+20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color_map[compo.category], 2)"
        },
        {
            "comment": "This code draws bounding boxes on an original image based on given component coordinates. It accepts the original image, component bboxes, color, line thickness, show flag, write path, name for image, is_return flag, and wait key. If the 'show' flag is True, it displays the labeled image with bounding boxes using OpenCV's imshow function. If 'write_path' is not None, it saves the labeled image to the specified file path using imwrite. The function returns the board image which can be useful for further processing if needed.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_draw.py\":27-55",
            "content": "    if show:\n        cv2.imshow(name, board)\n        cv2.waitKey(0)\n    if write_path is not None:\n        cv2.imwrite(write_path, board)\n    return board\ndef draw_bounding_box(org, components, color=(0, 255, 0), line=2,\n                      show=False, write_path=None, name='board', is_return=False, wait_key=0):\n    \"\"\"\n    Draw bounding box of components on the original image\n    :param org: original image\n    :param components: bbox [(column_min, row_min, column_max, row_max)]\n                    -> top_left: (column_min, row_min)\n                    -> bottom_right: (column_max, row_max)\n    :param color: line color\n    :param line: line thickness\n    :param show: show or not\n    :return: labeled image\n    \"\"\"\n    if not show and write_path is None and not is_return: return\n    board = org.copy()\n    for compo in components:\n        bbox = compo.put_bbox()\n        board = cv2.rectangle(board, (bbox[0], bbox[1]), (bbox[2], bbox[3]), color, line)\n    if show:\n        cv2.imshow(name, board)\n        if wait_key is not None:"
        },
        {
            "comment": "The code snippet is a part of the function `draw_line()` that draws detected lines on the original image. It takes in an original image (`org`), list of lines (`lines`), color for drawing (`color`) and boolean flag (`show`) as inputs, and returns an image with lines drawn. The code iterates over each line in `line_h` and `line_v`, extracting the head and end points of each line. Then, it uses the cv2 library's `cv2.line()` function to draw the lines on a copy of the original image (`board`) with specified color and thickness. If `show` is set to True, the drawn image is displayed using `cv2.waitKey()`. Additionally, there's an optional write path (`write_path`) where the drawn image can be saved as a new file using `cv2.imwrite()`, but only if it is not None.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_draw.py\":56-82",
            "content": "            cv2.waitKey(wait_key)\n        if wait_key == 0:\n            cv2.destroyWindow(name)\n    if write_path is not None:\n        # board = cv2.resize(board, (1080, 1920))\n        # board = board[100:-110]\n        cv2.imwrite(write_path, board)\n    return board\ndef draw_line(org, lines, color=(0, 255, 0), show=False):\n    \"\"\"\n    Draw detected lines on the original image\n    :param org: original image\n    :param lines: [line_h, line_v]\n            -> line_h: horizontal {'head':(column_min, row), 'end':(column_max, row), 'thickness':int)\n            -> line_v: vertical {'head':(column, row_min), 'end':(column, row_max), 'thickness':int}\n    :param color: drawn color\n    :param show: show or not\n    :return: image with lines drawn\n    \"\"\"\n    board = org.copy()\n    line_h, line_v = lines\n    for line in line_h:\n        cv2.line(board, tuple(line['head']), tuple(line['end']), color, line['thickness'])\n    for line in line_v:\n        cv2.line(board, tuple(line['head']), tuple(line['end']), color, line['thickness'])"
        },
        {
            "comment": "This function takes a set of components and draws their boundaries on an image, returning the resulting board. It also provides the option to display the drawn board using OpenCV functions. The code initializes a binary board of zeros, then iterates through each component's boundary points, setting them to white in the board array. Finally, if 'show' is set to True, it displays the drawn board as an image.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_draw.py\":83-109",
            "content": "    if show:\n        cv2.imshow('img', board)\n        cv2.waitKey(0)\n    return board\ndef draw_boundary(components, shape, show=False):\n    \"\"\"\n    Draw boundary of objects on the black withe\n    :param components: boundary: [top, bottom, left, right]\n                        -> up, bottom: (column_index, min/max row border)\n                        -> left, right: (row_index, min/max column border) detect range of each row\n    :param shape: shape or original image\n    :param show: show or not\n    :return: drawn board\n    \"\"\"\n    board = np.zeros(shape[:2], dtype=np.uint8)  # binary board\n    for component in components:\n        # up and bottom: (column_index, min/max row border)\n        for point in component.boundary[0] + component.boundary[1]:\n            board[point[1], point[0]] = 255\n        # left, right: (row_index, min/max column border)\n        for point in component.boundary[2] + component.boundary[3]:\n            board[point[0], point[1]] = 255\n    if show:\n        cv2.imshow('rec', board)\n        cv2.waitKey(0)"
        },
        {
            "comment": "The code defines two functions: draw_region and draw_region_bin. Both functions take a region, board, and optional show parameter. They modify the board by coloring or marking specific points within the given region. If show is True, they display the modified board with cv2.imshow.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_draw.py\":110-131",
            "content": "    return board\ndef draw_region(region, broad, show=False):\n    color = (rint(0,255), rint(0,255), rint(0,255))\n    for point in region:\n        broad[point[0], point[1]] = color\n    if show:\n        cv2.imshow('region', broad)\n        cv2.waitKey()\n    return broad\ndef draw_region_bin(region, broad, show=False):\n    for point in region:\n        broad[point[0], point[1]] = 255\n    if show:\n        cv2.imshow('region', broad)\n        cv2.waitKey()\n    return broad"
        }
    ]
}