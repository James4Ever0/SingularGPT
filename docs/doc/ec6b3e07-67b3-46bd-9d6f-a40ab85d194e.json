{
    "summary": "The `Text` class represents text elements with properties and methods for justification and merging. The code initializes word width based on content length, detects text location using a binary map, and visualizes the text as a rectangle on an image.",
    "details": [
        {
            "comment": "The class `Text` represents a text with its id, content, location, width, height, and area. It has a method `is_justified` that checks if an element is justified based on the maximum bias for justification, direction (vertical or horizontal), and location of another element `ele_b`.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/text_detection/Text.py\":0-32",
            "content": "import cv2\nimport numpy as np\nclass Text:\n    def __init__(self, id, content, location):\n        self.id = id\n        self.content = content\n        self.location = location\n        self.width = self.location['right'] - self.location['left']\n        self.height = self.location['bottom'] - self.location['top']\n        self.area = self.width * self.height\n        self.word_width = self.width / len(self.content)\n    '''\n    ********************************\n    *** Relation with Other text ***\n    ********************************\n    '''\n    def is_justified(self, ele_b, direction='h', max_bias_justify=4):\n        '''\n        Check if the element is justified\n        :param max_bias_justify: maximum bias if two elements to be justified\n        :param direction:\n             - 'v': vertical up-down connection\n             - 'h': horizontal left-right connection\n        '''\n        l_a = self.location\n        l_b = ele_b.location\n        # connected vertically - up and below\n        if direction == 'v':\n            # left and right should be justified"
        },
        {
            "comment": "This code checks if two text elements are on the same row (horizontal) or column (vertical) by comparing their positions and justification. It returns True if they meet the criteria, otherwise False.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/text_detection/Text.py\":33-55",
            "content": "            if abs(l_a['left'] - l_b['left']) < max_bias_justify and abs(l_a['right'] - l_b['right']) < max_bias_justify:\n                return True\n            return False\n        elif direction == 'h':\n            # top and bottom should be justified\n            if abs(l_a['top'] - l_b['top']) < max_bias_justify and abs(l_a['bottom'] - l_b['bottom']) < max_bias_justify:\n                return True\n            return False\n    def is_on_same_line(self, text_b, direction='h', bias_gap=4, bias_justify=4):\n        '''\n        Check if the element is on the same row(direction='h') or column(direction='v') with ele_b\n        :param direction:\n             - 'v': vertical up-down connection\n             - 'h': horizontal left-right connection\n        :return:\n        '''\n        l_a = self.location\n        l_b = text_b.location\n        # connected vertically - up and below\n        if direction == 'v':\n            # left and right should be justified\n            if self.is_justified(text_b, direction='v', max_bias_justify=bias_justify):"
        },
        {
            "comment": "This code compares the positions of two text boxes, checking for overlap and alignment in both horizontal (h) and vertical (v) directions. If there is an overlap or proper justification in either direction, it returns True; otherwise, False. The is_intersected function uses these checks to determine if two text boxes intersect or not.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/text_detection/Text.py\":56-77",
            "content": "                # top and bottom should be connected (small gap)\n                if abs(l_a['bottom'] - l_b['top']) < bias_gap or abs(l_a['top'] - l_b['bottom']) < bias_gap:\n                    return True\n            return False\n        elif direction == 'h':\n            # top and bottom should be justified\n            if self.is_justified(text_b, direction='h', max_bias_justify=bias_justify):\n                # top and bottom should be connected (small gap)\n                if abs(l_a['right'] - l_b['left']) < bias_gap or abs(l_a['left'] - l_b['right']) < bias_gap:\n                    return True\n            return False\n    def is_intersected(self, text_b, bias):\n        l_a = self.location\n        l_b = text_b.location\n        left_in = max(l_a['left'], l_b['left']) + bias\n        top_in = max(l_a['top'], l_b['top']) + bias\n        right_in = min(l_a['right'], l_b['right'])\n        bottom_in = min(l_a['bottom'], l_b['bottom'])\n        w_in = max(0, right_in - left_in)\n        h_in = max(0, bottom_in - top_in)"
        },
        {
            "comment": "This code defines a method `merge_text` that takes another `Text` object, compares their positions, and merges them into one by updating the location, width, height, and area attributes. The method also combines the contents of both texts into a single string.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/text_detection/Text.py\":78-103",
            "content": "        area_in = w_in * h_in\n        if area_in > 0:\n            return True\n    '''\n    ***********************\n    *** Revise the Text ***\n    ***********************\n    '''\n    def merge_text(self, text_b):\n        text_a = self\n        top = min(text_a.location['top'], text_b.location['top'])\n        left = min(text_a.location['left'], text_b.location['left'])\n        right = max(text_a.location['right'], text_b.location['right'])\n        bottom = max(text_a.location['bottom'], text_b.location['bottom'])\n        self.location = {'left': left, 'top': top, 'right': right, 'bottom': bottom}\n        self.width = self.location['right'] - self.location['left']\n        self.height = self.location['bottom'] - self.location['top']\n        self.area = self.width * self.height\n        left_element = text_a\n        right_element = text_b\n        if text_a.location['left'] > text_b.location['left']:\n            left_element = text_b\n            right_element = text_a\n        self.content = left_element.content + ' ' + right_element.content"
        },
        {
            "comment": "This code initializes the word width based on the text content length and then defines a function to adjust the bounding box of the text by checking the binary map and shrinking the top and bottom values accordingly.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/text_detection/Text.py\":104-131",
            "content": "        self.word_width = self.width / len(self.content)\n    def shrink_bound(self, binary_map):\n        bin_clip = binary_map[self.location['top']:self.location['bottom'], self.location['left']:self.location['right']]\n        height, width = np.shape(bin_clip)\n        shrink_top = 0\n        shrink_bottom = 0\n        for i in range(height):\n            # top\n            if shrink_top == 0:\n                if sum(bin_clip[i]) == 0:\n                    shrink_top = 1\n                else:\n                    shrink_top = -1\n            elif shrink_top == 1:\n                if sum(bin_clip[i]) != 0:\n                    self.location['top'] += i\n                    shrink_top = -1\n            # bottom\n            if shrink_bottom == 0:\n                if sum(bin_clip[height-i-1]) == 0:\n                    shrink_bottom = 1\n                else:\n                    shrink_bottom = -1\n            elif shrink_bottom == 1:\n                if sum(bin_clip[height-i-1]) != 0:\n                    self.location['bottom'] -= i"
        },
        {
            "comment": "This code is iterating through the width of an image, determining if there are any non-zero pixels on either side. It then calculates the location and width of a detected text based on these iterations. If no non-zero pixels are found on both sides, it breaks out of the loop.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/text_detection/Text.py\":132-163",
            "content": "                    shrink_bottom = -1\n            if shrink_top == -1 and shrink_bottom == -1:\n                break\n        shrink_left = 0\n        shrink_right = 0\n        for j in range(width):\n            # left\n            if shrink_left == 0:\n                if sum(bin_clip[:, j]) == 0:\n                    shrink_left = 1\n                else:\n                    shrink_left = -1\n            elif shrink_left == 1:\n                if sum(bin_clip[:, j]) != 0:\n                    self.location['left'] += j\n                    shrink_left = -1\n            # right\n            if shrink_right == 0:\n                if sum(bin_clip[:, width-j-1]) == 0:\n                    shrink_right = 1\n                else:\n                    shrink_right = -1\n            elif shrink_right == 1:\n                if sum(bin_clip[:, width-j-1]) != 0:\n                    self.location['right'] -= j\n                    shrink_right = -1\n            if shrink_left == -1 and shrink_right == -1:\n                break\n        self.width = self.location['right'] - self.location['left']"
        },
        {
            "comment": "This code calculates the height, area, and word width of a text element based on its location. It also includes a function to visualize the element as a rectangle on an image using OpenCV's rectangle() function.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/text_detection/Text.py\":164-175",
            "content": "        self.height = self.location['bottom'] - self.location['top']\n        self.area = self.width * self.height\n        self.word_width = self.width / len(self.content)\n    '''\n    *********************\n    *** Visualization ***\n    *********************\n    '''\n    def visualize_element(self, img, color=(0, 0, 255), line=1):\n        loc = self.location\n        cv2.rectangle(img, (loc['left'], loc['top']), (loc['right'], loc['bottom']), color, line)"
        }
    ]
}