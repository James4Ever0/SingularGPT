{
    "summary": "The code defines a Bbox class for image processing tasks, calculates bounding box area and coordinates, uses NMS to compare relationships, and determines IoU between two boxes.",
    "details": [
        {
            "comment": "This code defines a Bbox class with attributes representing the minimum and maximum column and row values of a bounding box. It also provides methods to calculate the bounding box area, put the bounding box coordinates, and compare two bounding boxes for their relationship.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Bbox.py\":0-33",
            "content": "import numpy as np\nimport component_detection.lib_ip.ip_draw as draw\nclass Bbox:\n    def __init__(self, col_min, row_min, col_max, row_max):\n        self.col_min = col_min\n        self.row_min = row_min\n        self.col_max = col_max\n        self.row_max = row_max\n        self.width = col_max - col_min\n        self.height = row_max - row_min\n        self.box_area = self.width * self.height\n    def put_bbox(self):\n        return self.col_min, self.row_min, self.col_max, self.row_max\n    def bbox_cal_area(self):\n        self.box_area = self.width * self.height\n        return self.box_area\n    def bbox_relation(self, bbox_b):\n        \"\"\"\n        :return: -1 : a in b\n                 0  : a, b are not intersected\n                 1  : b in a\n                 2  : a, b are identical or intersected\n        \"\"\"\n        col_min_a, row_min_a, col_max_a, row_max_a = self.put_bbox()\n        col_min_b, row_min_b, col_max_b, row_max_b = bbox_b.put_bbox()\n        # if a is in b\n        if col_min_a > col_min_b and row_min_a > row_min_b and col_max_a < col_max_b and row_max_a < row_max_b:"
        },
        {
            "comment": "This code calculates the relationship between two rectangles using non-maximum suppression (NMS). It returns -1 if bbox_b is entirely inside bbox_a, 0 if they are not intersected, 1 if bbox_a is entirely inside bbox_b, and 2 if they are intersected. The function uses the put_bbox() method to extract the coordinates of each rectangle and adjusts them with a bias before calculating the intersection area.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Bbox.py\":34-60",
            "content": "            return -1\n        # if b is in a\n        elif col_min_a < col_min_b and row_min_a < row_min_b and col_max_a > col_max_b and row_max_a > row_max_b:\n            return 1\n        # a and b are non-intersect\n        elif (col_min_a > col_max_b or row_min_a > row_max_b) or (col_min_b > col_max_a or row_min_b > row_max_a):\n            return 0\n        # intersection\n        else:\n            return 2\n    def bbox_relation_nms(self, bbox_b, bias=(0, 0)):\n        '''\n        Calculate the relation between two rectangles by nms\n       :return: -1 : a in b\n         0  : a, b are not intersected\n         1  : b in a\n         2  : a, b are intersected\n       '''\n        col_min_a, row_min_a, col_max_a, row_max_a = self.put_bbox()\n        col_min_b, row_min_b, col_max_b, row_max_b = bbox_b.put_bbox()\n        bias_col, bias_row = bias\n        # get the intersected area\n        col_min_s = max(col_min_a - bias_col, col_min_b - bias_col)\n        row_min_s = max(row_min_a - bias_row, row_min_b - bias_row)\n        col_max_s = min(col_max_a + bias_col, col_max_b + bias_col)"
        },
        {
            "comment": "This code calculates the intersection over union (IoU) between two bounding boxes. If the IoU is 0, it returns 0. If one box is fully contained in the other, it returns -1 or 1 respectively. If the boxes intersect with a certain threshold, it returns 2. The function also converts the bounding box to a relative position based on a base coordinator.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Bbox.py\":61-90",
            "content": "        row_max_s = min(row_max_a + bias_row, row_max_b + bias_row)\n        w = np.maximum(0, col_max_s - col_min_s)\n        h = np.maximum(0, row_max_s - row_min_s)\n        inter = w * h\n        area_a = (col_max_a - col_min_a) * (row_max_a - row_min_a)\n        area_b = (col_max_b - col_min_b) * (row_max_b - row_min_b)\n        iou = inter / (area_a + area_b - inter)\n        ioa = inter / self.box_area\n        iob = inter / bbox_b.box_area\n        if iou == 0 and ioa == 0 and iob == 0:\n            return 0\n        # contained by b\n        if ioa >= 1:\n            return -1\n        # contains b\n        if iob >= 1:\n            return 1\n        # not intersected with each other\n        # intersected\n        if iou >= 0.02 or iob > 0.2 or ioa > 0.2:\n            return 2\n        # if iou == 0:\n        # print('ioa:%.5f; iob:%.5f; iou:%.5f' % (ioa, iob, iou))\n        return 0\n    def bbox_cvt_relative_position(self, col_min_base, row_min_base):\n        '''\n        Convert to relative position based on base coordinator"
        },
        {
            "comment": "The code defines a Bbox class with attributes for column and row min/max values. It includes methods to merge two intersected bboxes, update bbox padding based on image shape and padding, and puts the bbox coordinates into variables. The main purpose is likely to manipulate and combine bounding boxes in an image processing task.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/Bbox.py\":91-115",
            "content": "        '''\n        self.col_min += col_min_base\n        self.col_max += col_min_base\n        self.row_min += row_min_base\n        self.row_max += row_min_base\n    def bbox_merge(self, bbox_b):\n        '''\n        Merge two intersected bboxes\n        '''\n        col_min_a, row_min_a, col_max_a, row_max_a = self.put_bbox()\n        col_min_b, row_min_b, col_max_b, row_max_b = bbox_b.put_bbox()\n        col_min = min(col_min_a, col_min_b)\n        col_max = max(col_max_a, col_max_b)\n        row_min = min(row_min_a, row_min_b)\n        row_max = max(row_max_a, row_max_b)\n        new_bbox = Bbox(col_min, row_min, col_max, row_max)\n        return new_bbox\n    def bbox_padding(self, image_shape, pad):\n        row, col = image_shape[:2]\n        self.col_min = max(self.col_min - pad, 0)\n        self.col_max = min(self.col_max + pad, col)\n        self.row_min = max(self.row_min - pad, 0)\n        self.row_max = min(self.row_max + pad, row)"
        }
    ]
}