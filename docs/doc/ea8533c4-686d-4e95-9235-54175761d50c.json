{
    "summary": "Both comments describe a function that utilizes numpy and opencv libraries for image processing. The function takes original and target image paths as input, performs template matching to find coordinates of the cropped image within the original image, and returns/prints the relevant coordinates as a list.",
    "details": [
        {
            "comment": "The code imports numpy and opencv libraries to find the coordinates of an object to the left of a target object. It converts the list of coordinates into NumPy array format, finds the index of the target point, determines the coordinates of the left side point, and iterates through the array to draw circles using different colors based on the condition. Finally, it prints the coordinates of the left side point.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/zexui_lib/base_functions.py\":0-21",
            "content": "import numpy as np \nimport cv2 \ndef find_obj_to_left_of_target_obj(target_obj, objects):\n  # Convert the given list of coordinates into NumPy array format\n  coordinates = np.array(objects)\n  # Find the index of the target point in the NumPy array of coordinates\n  target_index = np.where((coordinates == target_obj).all(axis=1))[0][0]\n  # Find the coordinates of the point that is just left side of the target point\n  left_side_coords = coordinates[target_index - 1]\n  # Iterate through the NumPy array of coordinates and draw a circle for each point with green color except for the point that is just left side of the target point\n  # for coord in coordinates:\n  #     if (coord == left_side_coords).all():\n  #         cv2.circle(img, tuple(coord), 10, (0, 0, 255), -1)\n  #     else:\n  #         cv2.circle(img, tuple(coord), 10, (0, 255, 0), -1)\n  # Print the coordinates of the point that is just left side of the target point\n  print(f\"Coordinates of the point just left side of the target point: {left_side_coords}\")"
        },
        {
            "comment": "This code defines a function to find the coordinates of an object to the right of a target object, converts list coordinates into NumPy array format, finds the index of target point in the array, and returns the coordinates of the next point. It also iterates through the array to draw circles for each point on an image, with green color except for the point just left of the target.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/zexui_lib/base_functions.py\":22-43",
            "content": "  return left_side_coords\ndef find_obj_to_right_of_target_obj(target_obj, objects):\n  # Convert the given list of coordinates into NumPy array format\n  coordinates = np.array(objects)\n  # Find the index of the target point in the NumPy array of coordinates\n  target_index = np.where((coordinates == target_obj).all(axis=1))[0][0]\n  # Find the coordinates of the point that is just right side of the target point\n  right_side_coords = coordinates[target_index + 1]\n  # Iterate through the NumPy array of coordinates and draw a circle for each point with green color except for the point that is just left side of the target point\n  # for coord in coordinates:\n  #     if (coord == left_side_coords).all():\n  #         cv2.circle(img, tuple(coord), 10, (0, 0, 255), -1)\n  #     else:\n  #         cv2.circle(img, tuple(coord), 10, (0, 255, 0), -1)\n  # Print the coordinates of the point that is just left side of the target point\n  print(f\"Coordinates of the point just left side of the target point: {right_side_coords}\")"
        },
        {
            "comment": "The code finds the coordinates of a point just below the target object in a given list of coordinates, converts them to a NumPy array, and returns those coordinates. It also has logic for drawing circles on an image but is not included in this segment.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/zexui_lib/base_functions.py\":44-65",
            "content": "  return right_side_coords\ndef find_obj_to_bottom_of_target_obj(target_obj, objects):\n  # Convert the given list of coordinates into NumPy array format\n  coordinates = np.array(objects)\n  # Find the index of the target point in the NumPy array of coordinates\n  target_index = np.where((coordinates == target_obj).all(axis=1))[0][0]\n  # Find the coordinates of the point that is just bottom side of the target point\n  bottom_side_coords = coordinates[np.where(coordinates[:, 0] == coordinates[target_index][0])[0][np.where(coordinates[:, 0] == coordinates[target_index][0])[0] > target_index][0]]\n  # Iterate through the NumPy array of coordinates and draw a circle for each point with green color except for the point that is just left side of the target point\n  # for coord in coordinates:\n  #     if (coord == left_side_coords).all():\n  #         cv2.circle(img, tuple(coord), 10, (0, 0, 255), -1)\n  #     else:\n  #         cv2.circle(img, tuple(coord), 10, (0, 255, 0), -1)\n  # Print the coordinates of the point that is just left side of the target point"
        },
        {
            "comment": "This function finds the coordinates of the point just above and just to the left side of a target point in a given list of coordinates. It converts the list into a NumPy array, finds the index of the target point, retrieves the top-side coordinates, and then iterates through the array to draw circles for each point using OpenCV. The left-side coordinates are not drawn with green color.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/zexui_lib/base_functions.py\":66-85",
            "content": "  print(f\"Coordinates of the point just left side of the target point: {bottom_side_coords}\")\n  return bottom_side_coords\ndef find_obj_to_top_of_target_obj(target_obj, objects):\n  # Convert the given list of coordinates into NumPy array format\n  coordinates = np.array(objects)\n  # Find the index of the target point in the NumPy array of coordinates\n  target_index = np.where((coordinates == target_obj).all(axis=1))[0][0]\n  # Find the coordinates of the point that is just top side of the target point\n  top_side_coords = coordinates[np.where(coordinates[:, 0] == coordinates[target_index][0])[0][np.where(coordinates[:, 0] == coordinates[target_index][0])[0] < target_index][-1]]\n  # Iterate through the NumPy array of coordinates and draw a circle for each point with green color except for the point that is just left side of the target point\n  # for coord in coordinates:\n  #     if (coord == left_side_coords).all():\n  #         cv2.circle(img, tuple(coord), 10, (0, 0, 255), -1)\n  #     else:\n  #         cv2.circle(img, tuple(coord), 10, (0, 255, 0), -1)"
        },
        {
            "comment": "This function takes original and target image paths as input, loads and converts them to grayscale, and uses template matching to find the coordinates of the cropped image within the original image. It then prints and returns the coordinates as a list.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/zexui_lib/base_functions.py\":87-109",
            "content": "  # Print the coordinates of the point that is just left side of the target point\n  print(f\"Coordinates of the point just left side of the target point: {top_side_coords}\")\n  return top_side_coords\ndef find_location_of_img_obj(original_path, target_path):\n  # Load the original image and convert it to grayscale\n  original_image = cv2.imread(original_path)\n  original_gray = cv2.cvtColor(original_image, cv2.COLOR_BGR2GRAY)\n  # Load the cropped image and convert it to grayscale\n  cropped_image = cv2.imread(target_path)\n  cropped_gray = cv2.cvtColor(cropped_image, cv2.COLOR_BGR2GRAY)\n  # Find the coordinates of the cropped image within the original image\n  result = cv2.matchTemplate(original_gray, cropped_gray, cv2.TM_CCOEFF_NORMED)\n  (_, _, minLoc, maxLoc) = cv2.minMaxLoc(result)\n  (left, top) = maxLoc\n  right = left + cropped_gray.shape[1]\n  bottom = top + cropped_gray.shape[0]\n  print(f\"Coordinates of cropped image with respect to original image: ({left}, {top}, {right}, {bottom})\")\n  return [left, top, right, bottom]"
        }
    ]
}