{
    "summary": "The code is a Python script for image preprocessing, including resizing, grayscaling, median blurring, and gradient map conversion. It also includes functions for filtering, binarization, and display or saving of the processed image with optional parameters.",
    "details": [
        {
            "comment": "The code is a Python script for image preprocessing. It reads an input image, applies resizing and gray-scaling transformations, and can optionally apply median blurring. The function \"gray_to_gradient\" converts grayscale images to gradient maps.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_preprocessing.py\":0-38",
            "content": "import cv2\nimport numpy as np\nfrom config.CONFIG_ZEXUI import Config\nC = Config()\ndef read_img(path, resize_height=None, kernel_size=None):\n    def resize_by_height(org):\n        w_h_ratio = org.shape[1] / org.shape[0]\n        resize_w = resize_height * w_h_ratio\n        re = cv2.resize(org, (int(resize_w), int(resize_height)))\n        return re\n    try:\n        img = cv2.imread(path)\n        if kernel_size is not None:\n            img = cv2.medianBlur(img, kernel_size)\n        if img is None:\n            print(\"*** Image does not exist ***\")\n            return None, None\n        if resize_height is not None:\n            img = resize_by_height(img)\n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        return img, gray\n    except Exception as e:\n        print(e)\n        print(\"*** Img Reading Failed ***\\n\")\n        return None, None\ndef gray_to_gradient(img):\n    if len(img.shape) == 3:\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    img_f = np.copy(img)\n    img_f = img_f.astype(\"float\")\n    kernel_h = np.array([[0,0,0], [0,-1.,1.], [0,0,0]])"
        },
        {
            "comment": "The code consists of three functions: `ip_preprocessing.py` includes a function that performs image filtering and calculates the gradient, another that reverses binary images, and a final one for binarization (converting an image to black and white) based on a given minimum gradient value. The binarized image can be displayed or saved to a specified file path with optional parameters for customization.",
            "location": "\"/media/root/Toshiba XG3/works/SingularGPT/docs/src/component_detection/lib_ip/ip_preprocessing.py\":39-68",
            "content": "    kernel_v = np.array([[0,0,0], [0,-1.,0], [0,1.,0]])\n    dst1 = abs(cv2.filter2D(img_f, -1, kernel_h))\n    dst2 = abs(cv2.filter2D(img_f, -1, kernel_v))\n    gradient = (dst1 + dst2).astype('uint8')\n    return gradient\ndef reverse_binary(bin, show=False):\n    \"\"\"\n    Reverse the input binary image\n    \"\"\"\n    r, bin = cv2.threshold(bin, 1, 255, cv2.THRESH_BINARY_INV)\n    if show:\n        cv2.imshow('binary_rev', bin)\n        cv2.waitKey()\n    return bin\ndef binarization(org, grad_min, show=False, write_path=None, wait_key=0):\n    grey = cv2.cvtColor(org, cv2.COLOR_BGR2GRAY)\n    grad = gray_to_gradient(grey)        # get RoI with high gradient\n    rec, binary = cv2.threshold(grad, grad_min, 255, cv2.THRESH_BINARY)    # enhance the RoI\n    morph = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, (3, 3))  # remove noises\n    if write_path is not None:\n        cv2.imwrite(write_path, morph)\n    if show:\n        cv2.imshow('binary', morph)\n        if wait_key is not None:\n            cv2.waitKey(wait_key)\n    return morph"
        }
    ]
}